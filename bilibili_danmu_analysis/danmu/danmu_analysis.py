import osfrom datetime import datetimeimport matplotlib.pyplot as pltimport pandas as pdfrom time import strftimefrom time import gmtime# 设置 Matplotlib 绘图时使用的无衬线字体为 “黑体”（SimHei），主要用于解决中文显示乱码的问题。plt.rcParams['font.sans-serif'] = ['SimHei']user_level = pd.read_excel('user_level.xlsx')excel_list = []for item in os.listdir('./'):    if item.endswith('.xlsx') and 'user_level' not in item:        excel_list.append(item)# print(excel_list)# 合并各个视频的弹幕数据danmu = pd.DataFrame()for item in excel_list:    excel = pd.read_excel(item, converters={'uid': str, 'id': str})    # 创建一个新列    excel['视频标题'] = item    danmu = pd.concat([danmu, excel], axis=0)print(danmu.shape)print(danmu.info())print(user_level.info())# 处理弹幕的时间danmu['弹幕创建时间'] = danmu['ctime'].map(datetime.fromtimestamp)danmu['年'] = danmu['弹幕创建时间'].map(lambda x: x.year)print(danmu.info())danmu['月份'] = danmu['弹幕创建时间'].map(lambda x: x.month)danmu['星期'] = danmu['弹幕创建时间'].map(datetime.isoweekday)danmu['小时'] = danmu['弹幕创建时间'].map(lambda x: x.hour)# print(danmu)plt.cla()plt.close('all')def show_plt(title):    """    统一格式设置并显示    """    plt.grid(True, alpha=0.3)    plt.title(title)    plt.tight_layout()    plt.show()# 基于时间的弹幕分析danmu_year = danmu[danmu['年'] == 2022]# 每个月发送弹幕的数量danmu_year.groupby('月份')[['id']].count().plot()show_plt('2022年每月期弹幕活跃度')# 每个月发送弹幕的人数danmu_year.groupby('月份')[['uid']].count().plot()show_plt('2022年每月弹幕人数活跃度')# 发现三月份弹幕的发送人数是最多的'''提出假设：1：季节？节假日偏多？2：视频进入推广池？'''# 按照星期danmu_year.groupby('星期')[['id']].count().plot()show_plt('2022年每星期弹幕活跃度')# 每个星期发送弹幕的人数（去重）danmu_year.groupby('星期')[['uid']].nunique().plot()show_plt('2022年每星期弹幕人数活跃度')# 结论：周天弹幕最多，周五周六下降# import pygwalker as pyq# # 分析每个月各个星期的弹幕发布# pyq.walk(danmu_year)# 分析每天的哪个小时段内的活跃度最高# 弹幕活跃度danmu_year.groupby('小时')[['id']].count().plot()show_plt('每小时弹幕活跃度')# 发送弹幕人数活跃度（去重）danmu_year.groupby('小时')[['uid']].count().plot()plt.xticks(range(0, 24, 1))  # 每1小时显示一个刻度show_plt('每小时弹幕人数活跃度')plt.cla()# 用户画像分析# 查看受众用户等级分布情况user_level['uid'] = user_level['uid'].astype(str)data = pd.merge(user_level, danmu, how='left', left_on='uid', right_on='uid')data.groupby('level')['uid'].count().sort_values('level', ascending=False).plot(kind='bar')# 查看谁发的弹幕最多 此方法会修改原始列表，使用transform则不会# data['用户弹幕数'] = data.group('uid')['id'].count.sort_values(ascending=False)data['用户弹幕数'] = data.groupby('uid')['id'].transform('count').sort_values(ascending=False)# 分析视频哪个时间段弹幕的数量最多# 对时间progress格式进行处理danmu['progress'] = danmu['progress'] / 1000danmu['progress'] = danmu['progress'].map(lambda x: strftime('%H:%M:%S', gmtime(x)))danmu['视频进度【时分】'] = danmu['progress'].str[:5]# 视频内容分析v1 = danmu[danmu['视频标题'] == '1、系统认识数据分析.xlsx']v1.groupby('视频进度【时分】')[['id']].count().sort_values('id', ascending=False).plot(kind='bar')show_plt('视频进度弹幕分析')# 其余视频的分析思路同上